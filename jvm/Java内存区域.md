### Java内存区域

#### 运行时数据区

- 程序计数器：
  - 每个线程都有一个程序计数器（线程私有），表示当前线程所执行字节码的指示器。循环，分支，跳转，异常处理都依赖这个计数器来完成。
  - 执行 Java 方法的时候,执行字节码指令的地址；执行本地方法的时候，计数器值为空。
  - 该区域是 JAVA虚拟机 规范中唯一不存在 OOM 情况的区域。
- 虚拟机栈：生命周期与线程相同（线程私有），每个方法执行的时候，都会创建一个栈帧。
  - 局部变量表：变量值存储空间，用于存放方法参数和方法内部定义的局部变量。
  - 操作数栈：又称为后入先出栈，执行逻辑运算不可缺少的容器。
  - 动态连接：每个栈帧（方法）包含一个指向运行时常量池中的引用，持有这个引用是为了支持动态连接，动态连接的知识又跟 Java方法调用 有关，后面补充相关知识。
  - 方法出口：方法结束时都必须回到方法最初调用的位置，所以方法返回时需要在栈帧中存储一些信息，用来恢复上层主调方法的执行状态。 方法正常退出时，保存程序计数器的地址；异常退出时，通常需要异常处理器来决定，栈帧就不保存这部分信息。
- 本地方法栈：与 `虚拟机栈` 类似，不过执行的是本地方法服务（非Java代码）。
- 堆：所有线程共享的一块内存区域，主要就是存放内存实例。具体内部区域划分就跟你使用哪种垃圾收集器有关了。
- 方法区：所有线程共享的一块内存区域，主要存放已被虚拟机加载的类定义，方法定义，常量等一些元数据信息，有一个别名叫“非堆”。
  - jdk1.8以后直接用本地内存实现方法区，并改名叫 Metaspace。正因为用本地内存，所以它的最大可使用可以达到机器内存的极限，但关于它的调优参数一直有个误解。

  ```
      `-XX:MetaspaceSize=8m` 并不是字面意思，它主要是控制 Metaspace GC 发生的初始阈值，而不是初始的 Metaspace 空间大小。但是这个阈值也是动态变化的（受其它调优参数的影响），我通过实际实验（-XX:+UseG1GC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:MetaspaceSize=8m -XX:MaxMetaspaceFreeRatio=0 -XX:MinMetaspaceFreeRatio=0），当 MetaspaceSize 达到 8M 以后，会触发 G1 的如下日志，说明触碰到了 Metadata GC 的阈值。

      2021-08-26T15:59:08.109+0800: [GC pause (Metadata GC Threshold) (young) (initial-mark), 0.0046983 secs]
      
      `-XX:MaxMetaspaceSize` 还是字面意思，限制 Metaspace 被committed的内存大小
  ```
  - 运行时常量池（Runtime Constant Pool）是方法区的一部分，Class 文件中的常量池表（Constant Pool Table，里面各种字面量和符号引用），被类加载后就放入方法区的`运行时常量池`
    。运行时常量池并不只有编译时才往里放东西，运行时也可以放新的常量，比如 `String.intern()`。
  - 直接内存（Direct Memory，又称 off-heap）并不属于`运行时数据区`的一部分，但是也会导致 OOM，跟 Java NIO 有关。




