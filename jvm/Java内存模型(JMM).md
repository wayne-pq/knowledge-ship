### Java内存模型

#### 定义

屏蔽各种硬件和操作系统之间的内存访问差异，以实现 Java 程序在各个平台下都能达到一致的内存访问效果。

#### 主内存和工作内存

主内存：所有变量都存储在主内存（物理上是虚拟机内存的一部分，但可以与硬件的主内存类比），线程间变量值均通过主内存传递。
工作内存：每条线程有自己的工作内存（可与处理器cache相类比），里面存储了变量的主内存副本，线程对变量的操作一定在都必须在工作内存中进行。

#### 主内存和工作内存交互指令

在 Java 虚拟机层面，主内存和工作内存交互细节由8种指令完成，每一种指令都是原子，不可再分的。

- lock（锁定）：作用于主内存变量。这个变量被一条线程标识为独占状态。
- unlock（解锁）：作用于主内存变量。这个变量从锁定状态中释放出来，释放后可以被其他线程锁定。
- read（读取）：作用于主线程变量。它把一个变量从主内存传输给线程的工作内存，以便 load 指令使用。
- load（载入）：作用于工作线程变量。它把 read 指令得到的变量放入工作内存的变量副本中。
- use（使用）：作用于工作线程变量。它把工作内存中一个变量的值传递给执行引擎。
- assign（赋值）：作用于工作线程变量。它把执行引擎接收到的值赋给工作内存中的变量。
- store（存储）：作用于工作线程变量。它把一个变量从工作内存传输给主内存，以便 write 指令使用。
- write（写入）：作用于主内存变量。它把 store 指令得到的变量放入主内存的变量中。

#### volatile

- 可见性
- 防止指令重排

### 原子性/可见性/有序性

- 原子性：
  - 基础数据类型因为有8种指令，已具备原子性（long/double等64位数据允许虚拟机分为两次32位操作来进行）。
  - 更大范围的原子性保障需要 lock/unlock 操作来保证，对应于字节码的monitorenter/monitorexit，对应于代码中的synchronized关键字。
- 可见性：
  - 一个线程修改了共享变量的值，另一个线程能够立即感知到这次修改
  - volatile特殊规则保证了新值能够立即同步到主内存，以及每次使用前立即从主内存刷新。所以volatile保证了多线程操作时变量的可见性。
- 有序性：
  - 单线程情况下，遵循as-if-serial语义，不管怎么重排序（编译器和处理器为了提高并行度），程序的执行结果不会被改变(编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序)。而在多线程情况下，则会出现执行结果不对的情况。
  - volatile，synchronized等保证线程之间操作的有序性。

### 先行发生原则（happens-before）

通过先行发生原则，判断数据是否有竞争，线程是否安全。

- 程序次序原则：单线程下，按照代码控制流顺序执行，即使有指令重排序，也不会改变对有数据依赖关系的两个操作的执行顺序（只针对单线程情况！）。
- 管程锁定原则：一个unlock操作先行发生于后面对同一个锁的lock操作。
- volatile原则：对一个volatile的写先行发生于后面对这个变量的读操作。
- 线程启动原则：Thread对象的start()方法先行发生于此线程内的任何操作。
- 线程终止原则：线程中的所有操作先行发生于此线程的终止检测（Thread对象的join()或者isAlive()）。
- 线程中断原则：对线程interrupt的调用先行发生于`被中断线程`代码检测到中断事件发生（Thread对象的interrupted()方法可以检测是否有中断发生）。
- 对象终结原则：一个对象初始化完成（构造函数执行完成）先行发生于finalize()方法的开始。
- 传递性原则：如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以得出操作A先行发生于操作C。









